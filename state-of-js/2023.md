---
theme: dracula
---

# FYI in December

----

Firefox 121 had been released.

That means nothing could prevent you to use `:has()`.

----

Design case study - The importance of avoid cross boundary(limit a problem only be concerned in one place): https://gitlab.dev.activenetwork.com/fee/react-foundation/-/merge_requests/983/diffs

----

`<PopperController>`

----

_@testing-library/react_ - Use `rerender` to easily update properties or mount/unmount component to reduce UT complexity.

This would result in more elegant and easier to understanding tests.

Compare below two examples:

----

Before

```jsx []
it('should focus the element referenced by "finalFocusRef" when component will unmount', async () => {
  const buttonRef = React.createRef<HTMLButtonElement>();
  const CompToUnmount = ({ finalFocusRef }: { finalFocusRef: React.RefObject<HTMLElement> }) => {
    useFocusFinalElement({ finalFocusRef });
    return null;
  };

  const Stage = () => {
    const [ show, setShow ] = React.useState(true);

    React.useEffect(() => {
      setShow(false);
    }, [ setShow ]);

    return (
      <main>
        <button ref={buttonRef}>final</button>
        {
          show && <CompToUnmount finalFocusRef={buttonRef} />
        }
      </main>
    );
  };

  render(
    <Stage></Stage>,
  );

  await waitFor(() => {
    expect(screen.getByText('final')).toHaveFocus();
  });
});
```
<!-- .element: style="font-size: 7.5pt" -->

----

After

```jsx [8-19]
it('should focus the element referenced by "finalFocusRef" when component will unmount', async () => {
  const buttonRef = React.createRef<HTMLButtonElement>();
  const CompToUnmount = ({ finalFocusRef }: { finalFocusRef: React.RefObject<HTMLElement> }) => {
    useFocusFinalElement({ finalFocusRef });
    return null;
  };

  const { rerender } = render(
    <main>
      <button ref={buttonRef}>final</button>
      <CompToUnmount finalFocusRef={buttonRef} />
    </main>,
  );

  rerender(
    <main>
      <button ref={buttonRef}>final</button>
    </main>,
  );

  await waitFor(() => {
    expect(screen.getByText('final')).toHaveFocus();
  });
});
```
<!-- .element: style="font-size: 9.5pt" -->

---

# State of Frontend 2023

----

## Trends

* [Web Development Trends](https://www.robinwieruch.de/web-development-trends/)
* [Rising Stars 2023](https://risingstars.js.org/2023/en)

----

## 2024 Predictions of React

[2024 Predictions by JavaScript Frontend Framework Maintainers](https://thenewstack.io/2024-predictions-by-javascript-frontend-framework-maintainers/)

----

### Next.js

* Development Principle: Migration as _Smooth_ as possible.
* Make the _Caching System_ easier for understanding and using.
* A new compiler based on `Rust` to make _Next.js_ faster on developers' machine.

----

### React

* Expecting more adoption of `React Server Component`.
* React Forget - React Forget will mean developers no longer have to use `useMemo` and `useCallback`

----

### Render patterns

* SPA
* SSR -> Streaming SSR -> partial hydration -> progressive hydration -> suspense -> server component
* SSG -> ISG
* MPA -> island architecture

Side effect of SSR re-embracing:
1. CSS-in-JS has a bad impact of SSR
2. css-module + utility css become popular(tailwind css)
3. check [DasiyUI](https://daisyui.com/components)

----

## JavaScript API

----

### error.cause

* [caniuse](https://caniuse.com/?search=Error.cause)
* [Use case 1](https://codepen.io/crusoexia/pen/xxMvXrK?editors=0010): Indicates the specific original cause of the error.
* [Use case 2](https://codepen.io/crusoexia/pen/gOqVGKx?editors=0010): Providing structured data for error parsing.

----

### Array

`array.toSorted()`
`array.toReversed()`
`array.toSpliced()`
`array.with()`

----

### Hashbang comment

```JavaScript
#!/usr/bin/env node

console.log("Hello world");
```

* [caniuse](https://caniuse.com/?search=hashbang)
* [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#hashbang_comments)
* [demo](https://codepen.io/crusoexia/pen/KKEzZdX)

----

## Temporal is still not ready

https://caniuse.com/?search=temporal

----

## htmx?

https://refine.dev/blog/what-is-htmx/#introduction

----

## Web Component

* **Lit** - Simple. Fast. Web Components.

* **Stencil** - A Web Component compiler for building fast, reusable UI components and static site generated Progressive Web Apps

----

## Build Tools

Can _Webpack_ be able to be replaced?

* swc
* Turbopack
* Vite

----

## Runtime

* Node.js - Dominate
* Deno - Typescript, support npm in 2023
* Bun - Fast, but not ready
    - [A comparation between node.js and Bun](https://www.builder.io/blog/bun-vs-node-js)

---

# Major changes of _Active_
## in 2024

----

* Shared _nodejs_ pipelines, for both libraries and node.js server.

----

* _nodejs_ k8s infrastructure. We could use node.js as the webserver or _next.js_ to build the FE and BFF layer.

----

* [nx](https://nx.dev/) would become the **offical task runner**. There will be plugins to help your project to match the infrastructure's needs.

----

* More support to micro-frontend architecture. More widgets.
